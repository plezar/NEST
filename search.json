[
  {
    "objectID": "preprocess.html",
    "href": "preprocess.html",
    "title": "Preprocess",
    "section": "",
    "text": "source\n\nclahe\n\n clahe (image:numpy.ndarray, clip_limit:float,\n        tile_grid_size:Tuple[int,int])\n\nApply Contrast Limited Adaptive Histogram Equalization (CLAHE) to a grayscale image.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nimage\nndarray\n2D array representing the input grayscale image.\n\n\nclip_limit\nfloat\nThreshold for contrast limiting. Higher values result in stronger contrast enhancement.\n\n\ntile_grid_size\nTuple\nSize (height, width) of the grid for histogram equalization (e.g., (8, 8)).\n\n\nReturns\nndarray\nCLAHE-enhanced image as a 2D array.",
    "crumbs": [
      "Preprocess"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "NEST",
    "section": "",
    "text": "Logo\n\n\nBelow you’ll find everything you need to get started with NEST, from installing the package to running a complete segmentation pipeline on your own images. The typical workflow involves:\n\nLoading and visualizing your raw image\n\nCorrecting illumination artifacts using CLAHE\n\nDividing the image into overlapping tiles\n\nSegmenting nuclei with a pre‐trained CellPose model\n\nStitching the tile‐level masks back into a full‐image segmentation\n\nExpanding nuclear labels to approximate cell boundaries\n\nOverlaying outlines and exporting results\n\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/plezar/NEST.git\nor from conda\n$ conda install -c plezar NEST\nor from pypi\n$ pip install NEST\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.\n\n\nHow to use\nThe core inputs required to run NEST are:\n\nInput Image\nA grayscale microscopy image (TIFF or similar) containing the nuclei you wish to segment.\nCellPose Model\nPath to a pre-trained CellPose model.\nExpansion Radius (µm)\nThe distance (in micrometers) by which to expand the nuclear masks to approximate whole-cell boundaries.\n\nGiven these inputs, NEST will:\n\nLoad and enhance the image for uniform illumination.\nSplit the image into overlapping tiles.\nRun segmentation on each tile.\nStitch tile masks into a global mask.\nOptionally expand masks to full-cell labels.\n\n\nfilename = \"../data/example_image.tif\"\nmodel_path = \"../data/example_model\"\nradius_um = 5.0\n\n\n\nExample Workflow\n\nReading the Input Image\nWe provide a sample image in the data folder. This image was acquired using a Leica Stellaris Dive system by stitching multiple 1024×1024 fields of view:\n\nimage = cv2.imread(filename, cv2.IMREAD_UNCHANGED)\n\nplt.imshow(image, cmap='grey')\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nFlat-Field Correction with CLAHE\nMicroscopy images often suffer from uneven illumination due to optical and sample variations. NEST uses Contrast Limited Adaptive Histogram Equalization (CLAHE) to address this:\n\nLocal Processing: The image is divided into small tiles (matching the stitching grid).\nHistogram Equalization: Each tile’s brightness distribution is equalized independently.\nContrast Limiting: A clip_limit prevents over-enhancement of noise.\nSeamless Merging: Tiles are blended back together to produce a smoothly corrected image.\n\n\nimage_enh = clahe(image, clip_limit = 4, tile_grid_size = count(image, t = 24, v = 0.1))\n\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 4))\n\nax1.imshow(image, cmap='grey')\nax1.set_title('Original image')\nax1.axis('off')\n\nax2.imshow(image_enh, cmap='grey')\nax2.set_title('CLAHE')\nax2.axis('off')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nNotice that local brightness gradients are flattened while preserving fine nuclear details.\n\n\nTiling the Enhanced Image\nTo maintain segmentation accuracy at the edges of each tile, NEST splits the enhanced image into 128×128 pixel tiles with a 20-pixel overlap. This overlap captures nuclei that span tile borders, reducing artifacts. Larger overlap improves accuracy but increases computational load.\n\ntiles, x, y = split(image_enh, tile_size = (128, 128), overlap = 20)\nprint(tiles.shape)\n\n(576, 128, 128)\n\n\n\n\nSegmentation\nThis example demonstrates nuclear segmentation, but the same workflow in principle can be applied to any segmentation task (membrane or cytoplasmic).\n\nmask = predict(model_path, tiles, cellpose_param=(0.32, 0.08), use_gpu=True)\nnp.save('../cache/mask.npy', mask)\n\n\nmask = np.load('../cache/mask.npy')\n\n\nfig, axes = plt.subplots(1, 4, figsize=(16,4))\ntitles = ['Tile 1', 'Tile 2', 'Tile 3', 'Tile 4']\n\nfor ax, m, img, title in zip(axes, mask[:4], tiles[:4], titles):\n    overlay = plot_outlines(m, img)\n    ax.imshow(overlay)\n    ax.axis('off')\n    ax.set_title(title)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nStitching\n\nglobal_mask = stitch(mask, x, y, 0.2)\n\n\nnuclei_overlay = plot_outlines(global_mask, image_enh, save_path=\"../data/nuclei_overlay.tif\")\nplt.imshow(nuclei_overlay)\nplt.axis('off')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nNuclear expansion\n\ncell_labels = expand_with_cap(global_mask,\n                             spacing = get_physical_size(filename, verbose=True),\n                             fixed_expand=10.0)\n\nPixel size = 0.534 × 0.534 µm/px\nPhysical size = 1363.1 × 1363.1 µm\n\n\n\ncell_overlay = plot_outlines(cell_labels, image_enh, save_path=\"../data/cell_overlay.tif\")\nplt.imshow(cell_overlay)\nplt.axis('off')\nplt.show()",
    "crumbs": [
      "NEST"
    ]
  },
  {
    "objectID": "labels.html",
    "href": "labels.html",
    "title": "Labels",
    "section": "",
    "text": "source\n\nexpand_with_cap\n\n expand_with_cap (label_image:numpy.ndarray, spacing:Tuple[float,float],\n                  fixed_expand:float=10.0, max_area_ratio:float=1.5)\n\nExpand labeled nuclei by up to a fixed radius, capped by max area ratio.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlabel_image\nndarray\n\n2D integer array of labels (0=background).\n\n\nspacing\nTuple\n\nPhysical size (µm) of each pixel along (row, column) axes.\n\n\nfixed_expand\nfloat\n10.0\nNominal expansion radius in µm. Default is 10.0.\n\n\nmax_area_ratio\nfloat\n1.5\nMaximum allowed area increase factor. Default is 1.5.\n\n\nReturns\nndarray\n\nDilated label image, where each pixel is assigned to the nearestoriginal label if within its per-pixel cap.\n\n\n\n\nsource\n\n\nget_physical_size\n\n get_physical_size (filename:str, verbose:bool=False)\n\nCompute the physical pixel size (µm/px) from a TIFF file’s resolution metadata.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfilename\nstr\n\nPath to the TIFF file.\n\n\nverbose\nbool\nFalse\nIf True, print resolution details. Default is False.\n\n\nReturns\nfloat\n\nPhysical size of a pixel in microns. Raises if pixels are non-square.\n\n\n\n\nsource\n\n\nplot_outlines\n\n plot_outlines (mask:numpy.ndarray, image:numpy.ndarray,\n                save_path:str=None)\n\nOverlay nuclear outlines from a mask onto an image and optionally save the result.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmask\nndarray\n\n2D array of integer labels where nonzero values indicate nuclei.\n\n\nimage\nndarray\n\nGrayscale image array of the same shape as mask.\n\n\nsave_path\nstr\nNone\nFile path in which to save the outline image. If None, no file is written.\n\n\nReturns\nmatplotlib.figure.Figure\n\nFigure object containing the outline overlay.\n\n\n\n\nsource\n\n\npredict\n\n predict (model_path:str, img_list:list, use_gpu:bool,\n          cellpose_param:tuple)\n\nRun a pretrained Cellpose model to generate segmentation masks for a list of images.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmodel_path\nstr\nPath to the pretrained Cellpose model file.\n\n\nimg_list\nlist\nIterable of image arrays to segment.\n\n\nuse_gpu\nbool\n\n\n\ncellpose_param\ntuple\nTuple specifying (flow_threshold, cellprob_threshold) for Cellpose evaluation.\n\n\nReturns\nndarray\nArray of shape (N, H, W) containing the segmentation masks for each input image.",
    "crumbs": [
      "Labels"
    ]
  },
  {
    "objectID": "tiles.html",
    "href": "tiles.html",
    "title": "Tiles",
    "section": "",
    "text": "source\n\nstitch\n\n stitch (tiles_list:List[numpy.ndarray], x_list:List[int],\n         y_list:List[int], iou_threshold:float)\n\nStitch tile masks into a global mask using IoU-based label matching.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntiles_list\nList\nList of 2D mask arrays for each tile.\n\n\nx_list\nList\nX-coordinates of tiles’ top-left corners.\n\n\ny_list\nList\nY-coordinates of tiles’ top-left corners.\n\n\niou_threshold\nfloat\nMinimum IoU threshold to match cell labels between overlapping tiles.\n\n\nReturns\nndarray\nStitched mask with consistent global labels.\n\n\n\n\nsource\n\n\nsave\n\n save (tiles:List[numpy.ndarray], filename:str, x:List[int], y:List[int],\n       output_dir:str)\n\nSave a list of image tiles to disk with filenames encoding their positions.\n\n\n\n\nType\nDetails\n\n\n\n\ntiles\nList\nList of image tiles to save.\n\n\nfilename\nstr\nOriginal filename to derive base name for tiles.\n\n\nx\nList\nX-coordinates corresponding to each tile.\n\n\ny\nList\nY-coordinates corresponding to each tile.\n\n\noutput_dir\nstr\nDirectory to save the tile files.\n\n\nReturns\nNone\n\n\n\n\n\nsource\n\n\nsplit\n\n split (image:numpy.ndarray, tile_size:Tuple[int,int], overlap:int,\n        tile_all:bool=True)\n\nSplit an image into tiles of specified size with a given overlap.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nimage\nndarray\n\nInput image array (2D grayscale or 3D color).\n\n\ntile_size\nTuple\n\nHeight and width of each tile, e.g., (128, 128).\n\n\noverlap\nint\n\nNumber of pixels each tile overlaps adjacent tiles.\n\n\ntile_all\nbool\nTrue\nIf True, include partial edge tiles to cover the entire image. Default is True.\n\n\nReturns\nTuple\n\nArray of shape (N, tile_h, tile_w[, C]) containing all tiles.\n\n\n\n\nsource\n\n\ncount\n\n count (image:numpy.ndarray, t:int=1024, v:float=0.1)\n\nCalculate the number of tiles in the vertical and horizontal directions.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nimage\nndarray\n\nInput image array.\n\n\nt\nint\n1024\nLength (in pixels) of each square tile. Default is 1024.\n\n\nv\nfloat\n0.1\nFractional overlap between tiles (e.g., 0.1 for 10%). Default is 0.1.\n\n\nReturns\nTuple\n\nNumber of tiles along the vertical axis (height).",
    "crumbs": [
      "Tiles"
    ]
  }
]